<#@ template debug="true" language="C#" #>
<#@ output extension=".generated.cs" #>
using System;
using System.Runtime.InteropServices;

namespace Spidermonkey {
    <# DefinePointerType("JSObjectPtr"); #>
    <# DefinePointerType("JSRuntimePtr"); #>
    <# DefinePointerType("JSContextPtr"); #>
    <# DefinePointerType("JSCompartmentPtr"); #>

    <# BeginPointerType("JSStringPtr"); #>

        // Creates a copy
        public unsafe string ToManagedString (JSContextPtr context) {
            var length = JSAPI.GetStringLength(this);

            uint numBytes = length * 2;
            var buffer = Marshal.AllocHGlobal((int)numBytes);

            try {
                if (!JSAPI.CopyStringChars(
                    context, 
                    new mozilla.Range(buffer, numBytes),
                    this
                ))
                    throw new Exception("String copy failed");

                var result = new String((char *)buffer, 0, (int)length);
                return result;
            } finally {
                Marshal.FreeHGlobal(buffer);
            }
        }

    }

    <# DefinePointerType("JSRootPtr"); #>

    <# DefineHandleType("JSHandleObject", "JSObjectPtr"); #>
    <# DefineHandleType("JSHandleValue", "JS.Value"); #>
    <# DefineHandleType("JSHandleId", "jsid"); #>

    <# DefineHandleType("JSMutableHandleValue", "JS.Value"); #>
}

<#+
    public void BeginPointerType (string name) {
        #>
        [StructLayout(LayoutKind.Sequential)]
        public struct <#= name #> {
            public IntPtr Pointer;

            public <#= name #> (IntPtr pointer) {
                Pointer = pointer;
            }

            public static implicit operator IntPtr (<#= name #> self) {
                return self.Pointer;
            }

            public static explicit operator <#= name #> (IntPtr ptr) {
                return new <#= name #> {
                    Pointer = ptr
                };
            }

            public bool IsZero {
                get {
                    return (Pointer == IntPtr.Zero);
                }
            }

            public bool IsNonzero {
                get {
                    return (Pointer != IntPtr.Zero);
                }
            }
        <#+
    }

    public void DefinePointerType (string name) {
        BeginPointerType(name);
        #>
        }
        <#+
    }

    public void DefineHandleType (string name, string valueName) {
        #>
        [StructLayout(LayoutKind.Sequential)]
        public struct <#= name #> {
            public IntPtr AddressOfTarget;

            public <#= name #> (IntPtr addressOfTarget) {
                AddressOfTarget = addressOfTarget;
            }

            public unsafe <#= valueName #> Get () {
                <#= valueName #> * pTarget = (<#= valueName #> *)AddressOfTarget;
                return *pTarget;
            }

            public static implicit operator <#= name #> (Rooted< <#= valueName #> > root) {
                JSRootPtr pRoot = root;
                return new <#= name #>(pRoot.Pointer);
            }
        }
        <#+
    }
#>