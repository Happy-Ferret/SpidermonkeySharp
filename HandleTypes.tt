<#@ template debug="true" language="C#" #>
<#@ output extension=".generated.cs" #>
using System;
using System.Runtime.InteropServices;

namespace Spidermonkey {
    <# BeginPointerType("JSObjectPtr", "IRootable"); #>

        bool IRootable.AddRoot (JSContextPtr context, JSRootPtr root) {
            return JSAPI.AddObjectRoot(context, root);
        }

        void IRootable.RemoveRoot (JSContextPtr context, JSRootPtr root) {
            JSAPI.RemoveObjectRoot(context, root);
        }
    }

    <# DefinePointerType("JSRuntimePtr"); #>
    <# DefinePointerType("JSContextPtr"); #>
    <# DefinePointerType("JSCompartmentPtr"); #>

    <# BeginPointerType("JSStringPtr"); #>

        // Creates a copy
        public unsafe string ToManagedString (JSContextPtr context) {
            var length = JSAPI.GetStringLength(this);

            uint numBytes = length * 2;
            var buffer = Marshal.AllocHGlobal((int)numBytes);

            try {
                if (!JSAPI.CopyStringChars(
                    context, 
                    new mozilla.Range(buffer, numBytes),
                    this
                ))
                    throw new Exception("String copy failed");

                var result = new String((char *)buffer, 0, (int)length);
                return result;
            } finally {
                Marshal.FreeHGlobal(buffer);
            }
        }

    }

    <# DefinePointerType("JSRootPtr"); #>

    <# DefineHandleType("JSHandleObject", "JSObjectPtr", rootable: true); #>
    <# DefineHandleType("JSHandleValue", "JS.Value", rootable: true); #>
    <# DefineHandleType("JSHandleId", "jsid", rootable: false); #>

    <# DefineHandleType("JSMutableHandleValue", "JS.Value", rootable: true); #>
}

<#+
    public void BeginPointerType (string name, params string[] interfaces) {
        #>
        [StructLayout(LayoutKind.Sequential)]
        public struct <#= name #> 
        <#+
            if (interfaces.Length > 0) {
                #> : <#= String.Join(", ", interfaces) #> <#+
            }
        #> {
            public IntPtr Pointer;

            public <#= name #> (IntPtr pointer) {
                Pointer = pointer;
            }

            public static implicit operator IntPtr (<#= name #> self) {
                return self.Pointer;
            }

            public static explicit operator <#= name #> (IntPtr ptr) {
                return new <#= name #> {
                    Pointer = ptr
                };
            }

            public bool IsZero {
                get {
                    return (Pointer == IntPtr.Zero);
                }
            }

            public bool IsNonzero {
                get {
                    return (Pointer != IntPtr.Zero);
                }
            }
        <#+
    }

    public void DefinePointerType (string name) {
        BeginPointerType(name);
        #>
        }
        <#+
    }

    public void DefineHandleType (string name, string valueName, bool rootable = false) {
        #>
        [StructLayout(LayoutKind.Sequential)]
        public struct <#= name #> {
            public IntPtr AddressOfTarget;

            public <#= name #> (IntPtr addressOfTarget) {
                AddressOfTarget = addressOfTarget;
            }

            public unsafe <#= valueName #> Get () {
                <#= valueName #> * pTarget = (<#= valueName #> *)AddressOfTarget;
                return *pTarget;
            }
        <#+
        if (rootable) {
            #>
            public static implicit operator <#= name #> (Rooted< <#= valueName #> > root) {
                return new <#= name #>(root.Root.Pointer);
            }
            <#+
        }
        #>
            }
        <#+
    }
#>